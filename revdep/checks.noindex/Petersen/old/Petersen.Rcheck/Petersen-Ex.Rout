
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin20 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "Petersen"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('Petersen')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("LP_AICc")
> ### * LP_AICc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_AICc
> ### Title: Create an AIC table comparing multiple LP fits
> ### Aliases: LP_AICc
> 
> ### ** Examples
> 
> 
> data(data_rodli)
> mt <- Petersen::LP_fit(data=data_rodli, p_model=~..time)
> m0 <- Petersen::LP_fit(data=data_rodli, p_model=~1)
> Petersen::LP_AICc(m0,mt)
  name_model   cond.ll n.parms nobs     AICc    Delta       AICcWt
2 p: ~..time -233.9047       2  229 471.8626  0.00000 9.999972e-01
1      p: ~1 -247.7207       1  229 497.4590 25.59642 2.765713e-06
> 
> 
> 
> 
> cleanEx()
> nameEx("LP_BTSPAS_est")
> ### * LP_BTSPAS_est
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_BTSPAS_est
> ### Title: Extract estimates of abundance after BTSPAS fit
> ### Aliases: LP_BTSPAS_est
> 
> ### ** Examples
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("LP_BTSPAS_fit_Diag")
> ### * LP_BTSPAS_fit_Diag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_BTSPAS_fit_Diag
> ### Title: Wrapper (*_fit) to call the Time Stratified Petersen Estimator
> ###   with Diagonal Entries function in BTSPAS.
> ### Aliases: LP_BTSPAS_fit_Diag
> 
> ### ** Examples
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("LP_BTSPAS_fit_NonDiag")
> ### * LP_BTSPAS_fit_NonDiag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_BTSPAS_fit_NonDiag
> ### Title: Wrapper (*_fit) to call the Time Stratified Petersen Estimator
> ###   with NON-Diagonal Entries function in BTSPAS.
> ### Aliases: LP_BTSPAS_fit_NonDiag
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("LP_CL_fit")
> ### * LP_CL_fit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_CL_fit
> ### Title: Fit the Chen-Lloyd model to estimate abundance using a
> ###   non-parametric smoother for a covariates
> ### Aliases: LP_CL_fit
> 
> ### ** Examples
> 
> 
> library(Petersen)
> data(data_NorthernPike)
> res <- LP_CL_fit(data_NorthernPike, "length")
> res$summary
  N_hat_f    N_hat_rn    N_hat N_hat_SE N_hat_conf_level N_hat_conf_method
1      ~1 (Intercept) 56620.94 5509.565             0.95              logN
  N_hat_LCL N_hat_UCL p_model cond.ll n.parms nobs    method
1  46789.66  68517.92      NA      NA      NA 7805 ChenLloyd
> 
> 
> 
> cleanEx()
> nameEx("LP_IS_est")
> ### * LP_IS_est
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_IS_est
> ### Title: Estimate abundance after the LP_IS conditional likelihood fit.
> ### Aliases: LP_IS_est
> 
> ### ** Examples
> 
> 
> data(data_wae_is_short)
> fit <- Petersen::LP_IS_fit(data=data_wae_is_short, p_model=~..time)
> fit$summary
  p_model  theta_model lambda_model
N ~..time ~-1 + ..time  ~-1 + ..cat
                                                                      name_model
N p: ~..time;  theta: ~-1 + ..time;  lambda: ~-1 + ..cat;  offsets 0,0,0,0,0,0,0
   cond.ll n.parms  nobs  method
N 70786.44       6 10077 full ll
> est <- LP_IS_est(fit, N_hat=~1)
> est$summary
  N_hat_f N_hat_conf_level N_hat_conf_method N_hat_rn    N_hat N_hat_SE
1      ~1             0.95              logN      All 314617.9 36222.21
  N_hat_LCL N_hat_UCL p_model  theta_model lambda_mode
1  251063.6  394260.2 ~..time ~-1 + ..time ~-1 + ..cat
                                                                      name_model
1 p: ~..time;  theta: ~-1 + ..time;  lambda: ~-1 + ..cat;  offsets 0,0,0,0,0,0,0
   cond.ll n.parms  nobs  method
1 70786.44       6 10077 full ll
> 
> 
> 
> cleanEx()
> nameEx("LP_IS_fit")
> ### * LP_IS_fit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_IS_fit
> ### Title: Fit a Lincoln-Petersen Model with incomplete stratification
> ### Aliases: LP_IS_fit
> 
> ### ** Examples
> 
> 
> data(data_wae_is_short)
> fit <- Petersen::LP_IS_fit(data=data_wae_is_short, p_model=~..time)
> fit$summary
  p_model  theta_model lambda_model
N ~..time ~-1 + ..time  ~-1 + ..cat
                                                                      name_model
N p: ~..time;  theta: ~-1 + ..time;  lambda: ~-1 + ..cat;  offsets 0,0,0,0,0,0,0
   cond.ll n.parms  nobs  method
N 70786.44       6 10077 full ll
> est <- LP_IS_est(fit, N_hat=~1)
> est$summary
  N_hat_f N_hat_conf_level N_hat_conf_method N_hat_rn    N_hat N_hat_SE
1      ~1             0.95              logN      All 314617.9 36222.21
  N_hat_LCL N_hat_UCL p_model  theta_model lambda_mode
1  251063.6  394260.2 ~..time ~-1 + ..time ~-1 + ..cat
                                                                      name_model
1 p: ~..time;  theta: ~-1 + ..time;  lambda: ~-1 + ..cat;  offsets 0,0,0,0,0,0,0
   cond.ll n.parms  nobs  method
1 70786.44       6 10077 full ll
> 
> 
> 
> 
> cleanEx()
> nameEx("LP_IS_print")
> ### * LP_IS_print
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_IS_print
> ### Title: Print the results from a fit a Lincoln-Petersen Model with
> ###   incomplete stratification
> ### Aliases: LP_IS_print
> 
> ### ** Examples
> 
> 
> data(data_wae_is_short)
> res <- Petersen::LP_IS_fit(data=data_wae_is_short, p_model=~-1 + ..cat:..time)
> LP_IS_print(res)

Model information: 

Model Name:  p: ~-1 + ..cat:..time;  theta: ~-1 + ..time;  lambda: ~-1 + ..cat;  offsets 0,0,0,0,0,0,0 
Neg Log-Likelihood:  -71018.68 
Number of Parameters:  8 
AICc value: -142021.4 

 

Raw data: 

$History
[1] "0F" "0M" "0U" "F0" "FF" "M0" "MM" "U0" "UU"

$counts
[1]  237   41 3058 1555   32 5071   40   42    1

$category
[1] "F" "M"


 

 
Initial values used for optimization routine: 

Initial capture probabilities: 
      time1      time2
F 0.0214139 0.01082925
M 0.0214139 0.01082925

Initial category proportions: 
lambda_ F lambda_ M 
      0.5       0.5 

Initial sub-sample  proportions: 
   theta_1    theta_2 
0.99362112 0.08333333 

Initial population size for optimization(simple Lincoln Petersen estimator is used) : 314,795 

 
Design matrix  and OFFSET vector for capture probabilities: 
    Beta...catF...time1 Beta...catM...time1 Beta...catF...time2
p1F                   1                   0                   0
p1M                   0                   1                   0
p2F                   0                   0                   1
p2M                   0                   0                   0
    Beta...catM...time2 OFFSET.vector
p1F                   0             0
p1M                   0             0
p2F                   0             0
p2M                   1             0

Design matrix and OFFSET vector for sub-sample proportions (theta): 
        Beta...time1 Beta...time2 OFFSET.vector
theta_1            1            0             0
theta_2            0            1             0

Design matrix and OFFSET vector for category proportions (lambda):
         ..catF OFFSET.vector
lambda_F      1             0


Find MLEs: 

MLEs for capture probabilities: 
       time1       time2
F 0.01146535 0.020643986
M 0.07658161 0.007930921

MLEs for category proportions: 
lambda_ F lambda_ M 
 0.674743  0.325257 

MLEs for sub-sample  proportions: 
  theta_1   theta_2 
0.9936211 0.0833333 

MLE for Population size :  206,507
MLE for Population size of category F : 139,339 
MLE for Population size of category M : 67,168
 
SE's of the MLEs 

SE's of the MLEs of capture probabilities: 
        time1       time2
F 0.002009477 0.003569036
M 0.015121929 0.001240106

SE's of the MLEs of the category proportions: 
 lambda_ F  lambda_ M 
0.06017088 0.06017088 

SE's of the MLEs of the sub-sample  proportions: 
    theta_1     theta_2 
0.000969662 0.004785221 

SE of the MLE of the population size:  26,475
SE for Population size of category F : 24,172 
SE for Population size of category M : 13,234

Observed and Expected counts for capture histories for the model  p: ~-1 + ..cat:..time;  theta: ~-1 + ..time;  lambda: ~-1 + ..cat;  offsets 0,0,0,0,0,0,0 
  History Observed.Counts Expected.counts     Residual Standardized.Residuals
1      U0              42      42.5318920 -0.531891968           -0.081566309
2      UU               1       0.4706046  0.529395437            0.771707324
3      F0            1555    1554.6107699  0.389230058            0.009909151
4      M0            5071    5070.4718173  0.528182724            0.007510317
5      FF              32      32.7698643 -0.769864335           -0.134496611
6      MM              40      40.5349888 -0.534988778           -0.084037335
7      0F             237     236.9610300  0.038969959            0.002533033
8      0M              41      40.9922556  0.007744408            0.001209708
9      0U            3058    3057.4874952  0.512504751            0.009338016

Standardized residual plot for the model p: ~-1 + ..cat:..time;  theta: ~-1 + ..time;  lambda: ~-1 + ..cat;  offsets 0,0,0,0,0,0,0 
> 
> 
> 
> 
> cleanEx()
> nameEx("LP_SPAS_est")
> ### * LP_SPAS_est
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_SPAS_est
> ### Title: Extract estimates of abundance after SPAS fit
> ### Aliases: LP_SPAS_est
> 
> ### ** Examples
> 
> 
> data(data_spas_harrison)
> fit <- Petersen::LP_SPAS_fit(data=data_spas_harrison,
+                               model.id="Pooling rows 5/6",
+                               row.pool.in=c(1,2,3,4,56,56),
+                               col.pool.in=c(1,2,3,4,5,6))
Using nlminb to find conditional MLE
outer mgc:  1967.318 
outer mgc:  1422.878 
outer mgc:  645.3606 
outer mgc:  317.7871 
outer mgc:  406.9156 
outer mgc:  51.60161 
outer mgc:  2.635485 
outer mgc:  14.02101 
outer mgc:  12.54391 
outer mgc:  1.368798 
outer mgc:  27.22498 
outer mgc:  48.33342 
outer mgc:  12.72531 
outer mgc:  24.86457 
outer mgc:  20.24618 
outer mgc:  21.56937 
outer mgc:  12.35667 
outer mgc:  21.1682 
outer mgc:  4.974679 
outer mgc:  12.1879 
outer mgc:  0.694162 
outer mgc:  1.066341 
outer mgc:  2.404293 
outer mgc:  1.016753 
outer mgc:  1.613808 
outer mgc:  1.984571 
outer mgc:  3.225646 
outer mgc:  3.483528 
outer mgc:  0.7228825 
outer mgc:  0.8425273 
outer mgc:  10.84383 
outer mgc:  0.9091613 
outer mgc:  0.466706 
outer mgc:  2.020493 
outer mgc:  0.4245068 
outer mgc:  1.816296 
outer mgc:  0.3484579 
outer mgc:  1.446409 
outer mgc:  0.434247 
outer mgc:  1.812811 
outer mgc:  0.3710481 
outer mgc:  1.506782 
outer mgc:  0.4637462 
outer mgc:  2.165541 
outer mgc:  2.902311 
outer mgc:  2.928614 
outer mgc:  2.788067 
outer mgc:  2.234718 
outer mgc:  1.660458 
outer mgc:  1.269126 
outer mgc:  0.7021785 
outer mgc:  0.4397476 
outer mgc:  0.4556117 
outer mgc:  0.1902366 
outer mgc:  0.1306426 
outer mgc:  0.07630603 
outer mgc:  0.04827152 
outer mgc:  0.02846116 
outer mgc:  0.01607083 
outer mgc:  0.009962472 
outer mgc:  0.008517718 
outer mgc:  0.003530268 
Convergence codes from nlminb  1 singular convergence (7) 
Finding conditional estimate of N
> fit$summary
                     p_model       name_model  cond.ll n.parms nobs method
1 Refer to row.pool/col.pool Pooling rows 5/6 47243.25      47 8256   SPAS
  cond.factor
1    3461.147
> est <- Petersen::LP_SPAS_est(fit)
> est$summary
  N_hat_f N_hat_rn   N_hat N_hat_SE N_hat_conf_level N_hat_conf_method
1      NA       NA 77965.6 15464.69             0.95      Large sample
  N_hat_LCL N_hat_UCL                    p_model       name_model  cond.ll
1  47655.38  108275.8 Refer to row.pool/col.pool Pooling rows 5/6 47243.25
  n.parms nobs method cond.factor
1      47 8256   SPAS    3461.147
> 
> 
> 
> cleanEx()
> nameEx("LP_SPAS_fit")
> ### * LP_SPAS_fit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_SPAS_fit
> ### Title: Fit a Stratified-Petersen SPAS model.
> ### Aliases: LP_SPAS_fit
> 
> ### ** Examples
> 
> data(data_spas_harrison)
> 
> fit <- Petersen::LP_SPAS_fit(data=data_spas_harrison,
+                               model.id="Pooling rows 5/6",
+                               row.pool.in=c(1,2,3,4,56,56),
+                               col.pool.in=c(1,2,3,4,5,6),quietly=TRUE)
> fit$summary
                     p_model       name_model  cond.ll n.parms nobs method
1 Refer to row.pool/col.pool Pooling rows 5/6 47243.25      47 8256   SPAS
  cond.factor
1    3461.147
> est <- Petersen::LP_SPAS_est(fit)
> est$summary
  N_hat_f N_hat_rn   N_hat N_hat_SE N_hat_conf_level N_hat_conf_method
1      NA       NA 77965.6 15464.69             0.95      Large sample
  N_hat_LCL N_hat_UCL                    p_model       name_model  cond.ll
1  47655.38  108275.8 Refer to row.pool/col.pool Pooling rows 5/6 47243.25
  n.parms nobs method cond.factor
1      47 8256   SPAS    3461.147
> 
> # make a nice report using the SPAS package functions
> SPAS::SPAS.print.model(fit$fit)
Model Name: Pooling rows 5/6 
   Date of Fit: 2024-01-24 15:30 
   Version of OPEN SPAS used : SPAS-R 2023-03-31 
 
Raw data 
     a    b    c   d   e   f    
01   4    2    1   1   0   0 130
02  12    7   14   1   3   0 330
03   7   11   41   9   1   1 790
04   1   13   40  12   9   1 667
05   0    1    8   8   3   0 309
06   0    0    0   0   0   1  65
   744 1187 2136 951 608 127   0

Row pooling setup : 1 2 3 4 56 56 
Col pooling setup : 1 2 3 4 5 6 
Physical pooling  : FALSE 
Theta pooling     : FALSE 
CJS pooling       : FALSE 


Chapman estimator of population size  70135  (SE  4503  )
 

Raw data AFTER PHYSICAL (but not logical) POOLING 
        pool1 pool2 pool3 pool4 pool5 pool6    
pool.1      4     2     1     1     0     0 130
pool.2     12     7    14     1     3     0 330
pool.3      7    11    41     9     1     1 790
pool.4      1    13    40    12     9     1 667
pool.56     0     1     8     8     3     0 309
pool.56     0     0     0     0     0     1  65
          744  1187  2136   951   608   127   0

Condition number of XX' where X= (physically) pooled matrix is  4121.288 
Condition number of XX' after logical pooling                   3461.147 

Large value of kappa (>1000) indicate that rows are approximately proportional which is not good

  Conditional   Log-Likelihood: 47243.25    ;  np: 47 ;  AICc: -94392.5 

  Code/Message from optimization is:  1 singular convergence (7) 

Estimates
             pool1  pool2  pool3 pool4 pool5 pool6 psi cap.prob exp factor
pool.1         3.6    2.7    0.8   0.8   0.0   0.1 130    0.005      195.8
pool.2        12.0    7.0   14.0   1.0   3.0   0.0 330    1.000        0.0
pool.3         7.0   11.0   41.0   9.0   1.0   1.0 790    1.000        0.0
pool.4         1.0   13.8   38.0  11.3  10.6   1.3 667    0.022       44.1
pool.56        0.0    1.1    7.6   7.6   3.5   0.0 309    0.025       39.6
pool.56        0.0    0.0    0.0   0.0   0.0   1.3  65    0.025       39.6
est unmarked 744.0 1185.0 2139.0 952.0 606.0 126.0   0       NA         NA
             Pop Est
pool.1         27162
pool.2           367
pool.3           860
pool.4         33542
pool.56        13356
pool.56         2679
est unmarked   77966

SE of above estimates
             pool1 pool2 pool3 pool4 pool5 pool6  psi cap.prob exp factor
pool.1         1.5   1.3   0.8   0.8   0.0   0.5 11.4    0.002       85.5
pool.2         3.5   2.6   3.7   1.0   1.7   0.0 18.2    0.000        0.0
pool.3         2.6   3.3   6.4   3.0   1.0   1.0 28.1    0.000        0.0
pool.4         1.0   3.7   6.2   3.2   2.5   1.3 25.8    0.009       17.6
pool.56        0.0   1.1   2.6   3.0   2.0   0.0 17.6    0.035       57.1
pool.56        0.0   0.0   0.0   0.0   0.0   1.3  8.1    0.035       57.1
est unmarked    NA    NA    NA    NA    NA    NA  0.0       NA         NA
             Pop Est
pool.1         11794
pool.2             0
pool.3             0
pool.4         13074
pool.56        18778
pool.56         3767
est unmarked   15465


Chisquare gof cutoff  : 0.1 
Chisquare gof value   : 1.131644 
Chisquare gof df      : 1 
Chisquare gof p       : 0.287425 
> 
> 
> 
> 
> cleanEx()
> nameEx("LP_TL_est")
> ### * LP_TL_est
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_TL_est
> ### Title: Estimate abundance after the LP_TL (tag loss) conditional
> ###   likelihood fit.
> ### Aliases: LP_TL_est
> 
> ### ** Examples
> 
> 
> data(data_kokanee_tagloss)
> fit <- Petersen::LP_TL_fit(data=data_kokanee_tagloss, p_model=~1, rho_model=~1, dt_type="notD")
> fit$summary
  p_model rho_model      name_model   cond.ll n.parms  nobs     method
1      ~1        ~1 p: ~1;  rho: ~1 -1488.626       2 11420 TL cond ll
> est <- Petersen::LP_TL_est(fit, N_hat=~1)
> est$summary
  N_hat_f    N_hat_rn    N_hat N_hat_SE N_hat_conf_level N_hat_conf_method
1      ~1 (Intercept) 103035.9 9099.521             0.95              logN
  N_hat_LCL N_hat_UCL p_model rho_model       name_model   cond.ll n.parms
1  86659.33  122507.2      ~1        ~1 p1: ~1;  rho: ~1 -1488.626       2
   nobs        method
1 14465 LP_TS CondLik
> 
> 
> 
> cleanEx()
> nameEx("LP_TL_fit")
> ### * LP_TL_fit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_TL_fit
> ### Title: Fit a Lincoln-Petersen Model with Tag Loss using conditional
> ###   likelihood
> ### Aliases: LP_TL_fit
> 
> ### ** Examples
> 
> 
> data(data_kokanee_tagloss)
> fit <- Petersen::LP_TL_fit(data=data_kokanee_tagloss, p_model=~1, rho_model=~1, dt_type="notD")
> fit$summary
  p_model rho_model      name_model   cond.ll n.parms  nobs     method
1      ~1        ~1 p: ~1;  rho: ~1 -1488.626       2 11420 TL cond ll
> est <- Petersen::LP_TL_est(fit, N_hat=~1)
> est$summary
  N_hat_f    N_hat_rn    N_hat N_hat_SE N_hat_conf_level N_hat_conf_method
1      ~1 (Intercept) 103035.9 9099.521             0.95              logN
  N_hat_LCL N_hat_UCL p_model rho_model       name_model   cond.ll n.parms
1  86659.33  122507.2      ~1        ~1 p1: ~1;  rho: ~1 -1488.626       2
   nobs        method
1 14465 LP_TS CondLik
> 
> 
> 
> 
> cleanEx()
> nameEx("LP_TL_simulate")
> ### * LP_TL_simulate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_TL_simulate
> ### Title: Simulate data from a Lincoln-Petersen Model with Tag Loss
> ### Aliases: LP_TL_simulate
> 
> ### ** Examples
> 
> 
> sim_data <-LP_TL_simulate(
+       dt_type="t2perm",  # permanent tag
+       N=1000,
+       cov1=function(N)         {rep(1,N)},
+       cov2=function(cov1)      {rep(1,  length(cov1))},
+       p1  =function(cov1, cov2){rep(.1, length(cov1))},
+       pST =function(cov1, cov2){rep(.25,length(cov1))},
+       rho1=function(cov1, cov2){rep(.70,length(cov1))},
+       rho2=function(cov1, cov2){rep(1,  length(cov1))},  # permanent second tag
+       p2  =function(cov1, cov2){rep(.1, length(cov1))},
+       seed=round(1000000*runif(1)))
> sim_data
  cov1 cov2 cap_hist freq
1    1    1     0010   99
2    1    1     1000   19
3    1    1     1010    4
4    1    1     1P00   66
5    1    1     1P0P    2
6    1    1     1P1P    2
> 
> 
> 
> 
> cleanEx()
> nameEx("LP_est")
> ### * LP_est
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_est
> ### Title: Estimate abundance after the LP conditional likelihood fit.
> ### Aliases: LP_est
> 
> ### ** Examples
> 
> 
> data(data_rodli)
> fit <- Petersen::LP_fit(data=data_rodli, p_model=~..time)
> fit$summary
  p_model name_model   cond.ll n.parms nobs  method
1 ~..time p: ~..time -233.9047       2  229 cond ll
> est <- Petersen::LP_est(fit, N_hat=~1)
> est$summary
  N_hat_f    N_hat_rn    N_hat N_hat_SE N_hat_conf_level N_hat_conf_method
1      ~1 (Intercept) 338.4737 25.49646             0.95              logN
  N_hat_LCL N_hat_UCL p_model name_model   cond.ll n.parms nobs  method
1  292.0154  392.3232 ~..time p: ~..time -233.9047       2  229 CondLik
> 
> 
> 
> cleanEx()
> nameEx("LP_est_adjust")
> ### * LP_est_adjust
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_est_adjust
> ### Title: Estimate abundance after empirical adjustments for various
> ###   factors.
> ### Aliases: LP_est_adjust
> 
> ### ** Examples
> 
> 
> data(data_rodli)
> rodli.fit <- Petersen::LP_fit(data=data_rodli, p_model=~..time)
> rodli.est <- Petersen::LP_est(rodli.fit)
> res <- Petersen::LP_est_adjust(rodli.est$summary$N_hat, rodli.est$summary$N_hat_SE,
+           tag.retention.est=.90, tag.retention.se=.05)
> res$summary
  N_hat_un N_hat_un_SE N_hat_adj N_hat_adj_SE N_hat_adj_LCL N_hat_adj_UCL
1 338.4737    25.49646  305.7493     28.89785       251.163      364.0406
> 
> 
> 
> cleanEx()
> nameEx("LP_fit")
> ### * LP_fit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_fit
> ### Title: Fit a Lincoln-Petersen Model using conditional likelihood
> ### Aliases: LP_fit
> 
> ### ** Examples
> 
> 
> data(data_rodli)
> fit <- Petersen::LP_fit(data=data_rodli, p_model=~..time)
> fit$summary
  p_model name_model   cond.ll n.parms nobs  method
1 ~..time p: ~..time -233.9047       2  229 cond ll
> res <- Petersen::LP_est(fit, N_hat=~1)
> res$summary
  N_hat_f    N_hat_rn    N_hat N_hat_SE N_hat_conf_level N_hat_conf_method
1      ~1 (Intercept) 338.4737 25.49646             0.95              logN
  N_hat_LCL N_hat_UCL p_model name_model   cond.ll n.parms nobs  method
1  292.0154  392.3232 ~..time p: ~..time -233.9047       2  229 CondLik
> 
> 
> 
> 
> cleanEx()
> nameEx("LP_modavg")
> ### * LP_modavg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_modavg
> ### Title: Create an table of individual estimates and the model averaged
> ###   values
> ### Aliases: LP_modavg
> 
> ### ** Examples
> 
> 
> data(data_rodli)
> mt <- Petersen::LP_fit(data=data_rodli, p_model=~..time)
> m0 <- Petersen::LP_fit(data=data_rodli, p_model=~1)
> Petersen::LP_modavg(m0,mt)
  .id       Modnames  K     AICc Delta_AICc    ModelLik       AICcWt        LL
1         p: ~..time  2 471.8626    0.00000 1.00000e+00 9.999972e-01 -233.9047
2              p: ~1  1 497.4590   25.59642 2.76572e-06 2.765713e-06 -247.7207
3     Model averaged NA       NA         NA          NA           NA        NA
  Estimate       SE N_hat_f    N_hat_rn N_hat_conf_level N_hat_conf_method
1 338.4737 25.49646      ~1 (Intercept)             0.95              logN
2 358.7542 28.57733      ~1 (Intercept)             0.95              logN
3 338.4737 25.49649    <NA>        <NA>             0.95              <NA>
  N_hat_LCL N_hat_UCL
1  292.0154  392.3232
2  306.8971  419.3738
3  288.5015  388.4459
> 
> 
> 
> 
> cleanEx()
> nameEx("LP_summary_stats")
> ### * LP_summary_stats
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_summary_stats
> ### Title: Compute summary statistics from the capture histories
> ### Aliases: LP_summary_stats
> 
> ### ** Examples
> 
> 
> data(data_rodli)
> LP_summary_stats(data_rodli)
   n1  n2 m2   p.recap        mf
1 109 177 57 0.5229358 0.3220339
> 
> 
> 
> 
> cleanEx()
> nameEx("LP_test_equal_mf")
> ### * LP_test_equal_mf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_test_equal_mf
> ### Title: Test for equal marked fractions in LP experiment
> ### Aliases: LP_test_equal_mf
> 
> ### ** Examples
> 
> 
> data(data_NorthernPike)
> LP_test_equal_mf(data_NorthernPike, "Sex")
$examine
[1] "equal mf"

$strat_var
[1] "Sex"

$table
        ..strat_var
cap_hist   F   M
      01 524 459
      11  89  68

$table.prop
        ..strat_var
cap_hist         F         M
      01 0.8548124 0.8709677
      11 0.1451876 0.1290323

$chisq.test

	Pearson's Chi-squared test with Yates' continuity correction

data:  tab
X-squared = 0.4942, df = 1, p-value = 0.4821


> 
> 
> 
> 
> cleanEx()
> nameEx("LP_test_equal_recap")
> ### * LP_test_equal_recap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LP_test_equal_recap
> ### Title: Test for equal recapture probability in LP experiment
> ### Aliases: LP_test_equal_recap
> 
> ### ** Examples
> 
> 
> data(data_NorthernPike)
> LP_test_equal_recap(data_NorthernPike, "Sex")
$examine
[1] "equal recap"

$strat_var
[1] "Sex"

$table
        ..strat_var
cap_hist    F    M
      10 3956 2709
      11   89   68

$table.prop
        ..strat_var
cap_hist          F          M
      10 0.97799753 0.97551314
      11 0.02200247 0.02448686

$chisq.test

	Pearson's Chi-squared test with Yates' continuity correction

data:  tab
X-squared = 0.34826, df = 1, p-value = 0.5551


> 
> 
> 
> 
> cleanEx()
> nameEx("cap_hist_to_n_m_u")
> ### * cap_hist_to_n_m_u
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cap_hist_to_n_m_u
> ### Title: Convert capture history data to n, m and u for use in BTSPAS
> ### Aliases: cap_hist_to_n_m_u
> 
> ### ** Examples
> 
> 
> data(data_btspas_diag1)
> cap_hist_to_n_m_u(data_btspas_diag1)
$..ts
 [1]  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19

$n1
 [1] 1465 1335  197 1335 1653  923  610 7969 6008 3770 4854 3350 1062  346   88
[16]   20

$m2
       
X1      [,1]
   [1,]   51
   [2,]  146
   [3,]   17
   [4,]  168
   [5,]   72
   [6,]   43
   [7,]   28
   [8,]  297
   [9,]  313
  [10,]  151
  [11,]  309
  [12,]  376
  [13,]  110
  [14,]   40
  [15,]   12
  [16,]    1

$u2
 [1] 14587  2854  1027  1945  2855  1323   933 57549 14846  5291  9249  4615
[13]  1433   446   120    23

> 
> data(data_btspas_nondiag1)
> cap_hist_to_n_m_u(data_btspas_nondiag1)
$..ts
 [1] 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41

$n1
 [1]  34 280 607 603 388 212 468 586 512 458 479 329 248 201 104

$m2
       
X1      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
   [1,]    0    0    0    0    0   11    2    0    0     0
   [2,]    0    0    0    3  118   18    6    3    0     0
   [3,]    0    0    1  149   76   33   16    3    1     0
   [4,]    0    0   42  163   69   34    1    0    0     0
   [5,]    0    1   39   84   35    1    3    1    0     0
   [6,]    0    1   29   60   14    5    2    0    1     0
   [7,]    0    3   82   84   19   11    2    1    0     0
   [8,]    0   20  154   56   53    9    1    1    1     0
   [9,]    0   16   44  146   83   25    3    3    0     1
  [10,]    0    2   52  125   82   13   14    3    0     0
  [11,]    0    0   83  133   43   12    5    2    0     0
  [12,]    0   12   96   60   29    8    0    1    0     0
  [13,]    0   19   72   37   17    7    0    0    0     0
  [14,]    0    7   55   23    6    1    0    0    0     0
  [15,]    0    7    3    3    0    0    0    0    0     0

$u2
 [1]     0     0     0     0  1420 27886  9284  4357 11871 14896  9910 16526
[13] 17443 16485  6776  4644  2190  1066   166

> 
> 
> 
> 
> 
> cleanEx()
> nameEx("logit")
> ### * logit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: logit
> ### Title: Logit and anti-logit function.
> ### Aliases: logit expit
> ### Keywords: ~misc
> 
> ### ** Examples
> 
> 
> ##---- compute the logit and its inverse
> logitp <- logit(.3)
> p <- expit(-.84)
> 
> 
> 
> 
> cleanEx()
> nameEx("split_cap_hist")
> ### * split_cap_hist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: split_cap_hist
> ### Title: Split a vector of capture histories into a matrix with one
> ###   column for each occasion
> ### Aliases: split_cap_hist
> 
> ### ** Examples
> 
> 
> # standard 2 character capture histor
> data(data_rodli)
> Petersen::split_cap_hist(data_rodli$cap_hist)
     t1  t2 
[1,] "1" "1"
[2,] "1" "0"
[3,] "0" "1"
> 
> # history vector with ".." separating the fields
> test <- c("1..1","1..0")
> split_cap_hist(test, sep=stringr::fixed(".."))
Warning in stringr::fixed(sep) :
  Coercing `pattern` to a plain character vector.
     t1  t2 
[1,] "1" "1"
[2,] "1" "0"
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  5.035 0.242 6.222 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
